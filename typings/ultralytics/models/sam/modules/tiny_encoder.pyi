"""
This type stub file was generated by pyright.
"""

import torch
import torch.nn as nn
from typing import List, Optional, Tuple, Union

class Conv2d_BN(torch.nn.Sequential):
    """
    A sequential container that performs 2D convolution followed by batch normalization.

    This module combines a 2D convolution layer with batch normalization, providing a common building block
    for convolutional neural networks. The batch normalization weights and biases are initialized to specific
    values for optimal training performance.

    Attributes:
        c (torch.nn.Conv2d): 2D convolution layer.
        bn (torch.nn.BatchNorm2d): Batch normalization layer.

    Examples:
        >>> conv_bn = Conv2d_BN(3, 64, ks=3, stride=1, pad=1)
        >>> input_tensor = torch.randn(1, 3, 224, 224)
        >>> output = conv_bn(input_tensor)
        >>> print(output.shape)
        torch.Size([1, 64, 224, 224])
    """
    def __init__(self, a: int, b: int, ks: int = ..., stride: int = ..., pad: int = ..., dilation: int = ..., groups: int = ..., bn_weight_init: float = ...) -> None:
        """
        Initialize a sequential container with 2D convolution followed by batch normalization.

        Args:
            a (int): Number of input channels.
            b (int): Number of output channels.
            ks (int, optional): Kernel size for the convolution.
            stride (int, optional): Stride for the convolution.
            pad (int, optional): Padding for the convolution.
            dilation (int, optional): Dilation factor for the convolution.
            groups (int, optional): Number of groups for the convolution.
            bn_weight_init (float, optional): Initial value for batch normalization weight.
        """
        ...
    


class PatchEmbed(nn.Module):
    """
    Embed images into patches and project them into a specified embedding dimension.

    This module converts input images into patch embeddings using a sequence of convolutional layers,
    effectively downsampling the spatial dimensions while increasing the channel dimension.

    Attributes:
        patches_resolution (Tuple[int, int]): Resolution of the patches after embedding.
        num_patches (int): Total number of patches.
        in_chans (int): Number of input channels.
        embed_dim (int): Dimension of the embedding.
        seq (nn.Sequential): Sequence of convolutional and activation layers for patch embedding.

    Examples:
        >>> import torch
        >>> patch_embed = PatchEmbed(in_chans=3, embed_dim=96, resolution=224, activation=nn.GELU)
        >>> x = torch.randn(1, 3, 224, 224)
        >>> output = patch_embed(x)
        >>> print(output.shape)
        torch.Size([1, 96, 56, 56])
    """
    def __init__(self, in_chans: int, embed_dim: int, resolution: int, activation) -> None:
        """
        Initialize patch embedding with convolutional layers for image-to-patch conversion and projection.

        Args:
            in_chans (int): Number of input channels.
            embed_dim (int): Dimension of the embedding.
            resolution (int): Input image resolution.
            activation (nn.Module): Activation function to use between convolutions.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Process input tensor through patch embedding sequence, converting images to patch embeddings."""
        ...
    


class MBConv(nn.Module):
    """
    Mobile Inverted Bottleneck Conv (MBConv) layer, part of the EfficientNet architecture.

    This module implements the mobile inverted bottleneck convolution with expansion, depthwise convolution,
    and projection phases, along with residual connections for improved gradient flow.

    Attributes:
        in_chans (int): Number of input channels.
        hidden_chans (int): Number of hidden channels after expansion.
        out_chans (int): Number of output channels.
        conv1 (Conv2d_BN): First convolutional layer for channel expansion.
        act1 (nn.Module): First activation function.
        conv2 (Conv2d_BN): Depthwise convolutional layer.
        act2 (nn.Module): Second activation function.
        conv3 (Conv2d_BN): Final convolutional layer for projection.
        act3 (nn.Module): Third activation function.
        drop_path (nn.Module): Drop path layer (Identity for inference).

    Examples:
        >>> in_chans, out_chans = 32, 64
        >>> mbconv = MBConv(in_chans, out_chans, expand_ratio=4, activation=nn.ReLU, drop_path=0.1)
        >>> x = torch.randn(1, in_chans, 56, 56)
        >>> output = mbconv(x)
        >>> print(output.shape)
        torch.Size([1, 64, 56, 56])
    """
    def __init__(self, in_chans: int, out_chans: int, expand_ratio: float, activation, drop_path: float) -> None:
        """
        Initialize the MBConv layer with specified input/output channels, expansion ratio, and activation.

        Args:
            in_chans (int): Number of input channels.
            out_chans (int): Number of output channels.
            expand_ratio (float): Channel expansion ratio for the hidden layer.
            activation (nn.Module): Activation function to use.
            drop_path (float): Drop path rate for stochastic depth.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Implement the forward pass of MBConv, applying convolutions and skip connection."""
        ...
    


class PatchMerging(nn.Module):
    """
    Merge neighboring patches in the feature map and project to a new dimension.

    This class implements a patch merging operation that combines spatial information and adjusts the feature
    dimension using a series of convolutional layers with batch normalization. It effectively reduces spatial
    resolution while potentially increasing channel dimensions.

    Attributes:
        input_resolution (Tuple[int, int]): The input resolution (height, width) of the feature map.
        dim (int): The input dimension of the feature map.
        out_dim (int): The output dimension after merging and projection.
        act (nn.Module): The activation function used between convolutions.
        conv1 (Conv2d_BN): The first convolutional layer for dimension projection.
        conv2 (Conv2d_BN): The second convolutional layer for spatial merging.
        conv3 (Conv2d_BN): The third convolutional layer for final projection.

    Examples:
        >>> input_resolution = (56, 56)
        >>> patch_merging = PatchMerging(input_resolution, dim=64, out_dim=128, activation=nn.ReLU)
        >>> x = torch.randn(4, 64, 56, 56)
        >>> output = patch_merging(x)
        >>> print(output.shape)
        torch.Size([4, 3136, 128])
    """
    def __init__(self, input_resolution: Tuple[int, int], dim: int, out_dim: int, activation) -> None:
        """
        Initialize the PatchMerging module for merging and projecting neighboring patches in feature maps.

        Args:
            input_resolution (Tuple[int, int]): The input resolution (height, width) of the feature map.
            dim (int): The input dimension of the feature map.
            out_dim (int): The output dimension after merging and projection.
            activation (nn.Module): The activation function used between convolutions.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Apply patch merging and dimension projection to the input feature map."""
        ...
    


class ConvLayer(nn.Module):
    """
    Convolutional Layer featuring multiple MobileNetV3-style inverted bottleneck convolutions (MBConv).

    This layer optionally applies downsample operations to the output and supports gradient checkpointing
    for memory efficiency during training.

    Attributes:
        dim (int): Dimensionality of the input and output.
        input_resolution (Tuple[int, int]): Resolution of the input image.
        depth (int): Number of MBConv layers in the block.
        use_checkpoint (bool): Whether to use gradient checkpointing to save memory.
        blocks (nn.ModuleList): List of MBConv layers.
        downsample (Optional[nn.Module]): Function for downsampling the output.

    Examples:
        >>> input_tensor = torch.randn(1, 64, 56, 56)
        >>> conv_layer = ConvLayer(64, (56, 56), depth=3, activation=nn.ReLU)
        >>> output = conv_layer(input_tensor)
        >>> print(output.shape)
        torch.Size([1, 3136, 128])
    """
    def __init__(self, dim: int, input_resolution: Tuple[int, int], depth: int, activation, drop_path: Union[float, List[float]] = ..., downsample: Optional[nn.Module] = ..., use_checkpoint: bool = ..., out_dim: Optional[int] = ..., conv_expand_ratio: float = ...) -> None:
        """
        Initialize the ConvLayer with the given dimensions and settings.

        This layer consists of multiple MobileNetV3-style inverted bottleneck convolutions (MBConv) and
        optionally applies downsampling to the output.

        Args:
            dim (int): The dimensionality of the input and output.
            input_resolution (Tuple[int, int]): The resolution of the input image.
            depth (int): The number of MBConv layers in the block.
            activation (nn.Module): Activation function applied after each convolution.
            drop_path (float | List[float], optional): Drop path rate. Single float or a list of floats for each MBConv.
            downsample (Optional[nn.Module], optional): Function for downsampling the output. None to skip downsampling.
            use_checkpoint (bool, optional): Whether to use gradient checkpointing to save memory.
            out_dim (Optional[int], optional): The dimensionality of the output. None means it will be the same as `dim`.
            conv_expand_ratio (float, optional): Expansion ratio for the MBConv layers.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Process input through convolutional layers, applying MBConv blocks and optional downsampling."""
        ...
    


class MLP(nn.Module):
    """
    Multi-layer Perceptron (MLP) module for transformer architectures.

    This module applies layer normalization, two fully-connected layers with an activation function in between,
    and dropout. It is commonly used in transformer-based architectures for processing token embeddings.

    Attributes:
        norm (nn.LayerNorm): Layer normalization applied to the input.
        fc1 (nn.Linear): First fully-connected layer.
        fc2 (nn.Linear): Second fully-connected layer.
        act (nn.Module): Activation function applied after the first fully-connected layer.
        drop (nn.Dropout): Dropout layer applied after the activation function.

    Examples:
        >>> import torch
        >>> from torch import nn
        >>> mlp = MLP(in_features=256, hidden_features=512, out_features=256, activation=nn.GELU, drop=0.1)
        >>> x = torch.randn(32, 100, 256)
        >>> output = mlp(x)
        >>> print(output.shape)
        torch.Size([32, 100, 256])
    """
    def __init__(self, in_features: int, hidden_features: Optional[int] = ..., out_features: Optional[int] = ..., activation=..., drop: float = ...) -> None:
        """
        Initialize a multi-layer perceptron with configurable input, hidden, and output dimensions.

        Args:
            in_features (int): Number of input features.
            hidden_features (Optional[int], optional): Number of hidden features.
            out_features (Optional[int], optional): Number of output features.
            activation (nn.Module): Activation function applied after the first fully-connected layer.
            drop (float, optional): Dropout probability.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Apply MLP operations: layer norm, FC layers, activation, and dropout to the input tensor."""
        ...
    


class Attention(torch.nn.Module):
    """
    Multi-head attention module with spatial awareness and trainable attention biases.

    This module implements a multi-head attention mechanism with support for spatial awareness, applying
    attention biases based on spatial resolution. It includes trainable attention biases for each unique
    offset between spatial positions in the resolution grid.

    Attributes:
        num_heads (int): Number of attention heads.
        scale (float): Scaling factor for attention scores.
        key_dim (int): Dimensionality of the keys and queries.
        nh_kd (int): Product of num_heads and key_dim.
        d (int): Dimensionality of the value vectors.
        dh (int): Product of d and num_heads.
        attn_ratio (float): Attention ratio affecting the dimensions of the value vectors.
        norm (nn.LayerNorm): Layer normalization applied to input.
        qkv (nn.Linear): Linear layer for computing query, key, and value projections.
        proj (nn.Linear): Linear layer for final projection.
        attention_biases (nn.Parameter): Learnable attention biases.
        attention_bias_idxs (torch.Tensor): Indices for attention biases.
        ab (torch.Tensor): Cached attention biases for inference, deleted during training.

    Examples:
        >>> attn = Attention(dim=256, key_dim=64, num_heads=8, resolution=(14, 14))
        >>> x = torch.randn(1, 196, 256)
        >>> output = attn(x)
        >>> print(output.shape)
        torch.Size([1, 196, 256])
    """
    def __init__(self, dim: int, key_dim: int, num_heads: int = ..., attn_ratio: float = ..., resolution: Tuple[int, int] = ...) -> None:
        """
        Initialize the Attention module for multi-head attention with spatial awareness.

        This module implements a multi-head attention mechanism with support for spatial awareness, applying
        attention biases based on spatial resolution. It includes trainable attention biases for each unique
        offset between spatial positions in the resolution grid.

        Args:
            dim (int): The dimensionality of the input and output.
            key_dim (int): The dimensionality of the keys and queries.
            num_heads (int, optional): Number of attention heads.
            attn_ratio (float, optional): Attention ratio, affecting the dimensions of the value vectors.
            resolution (Tuple[int, int], optional): Spatial resolution of the input feature map.
        """
        ...
    
    @torch.no_grad()
    def train(self, mode: bool = ...): # -> None:
        """Set the module in training mode and handle the 'ab' attribute for cached attention biases."""
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Apply multi-head attention with spatial awareness and trainable attention biases."""
        ...
    


class TinyViTBlock(nn.Module):
    """
    TinyViT Block that applies self-attention and a local convolution to the input.

    This block is a key component of the TinyViT architecture, combining self-attention mechanisms with
    local convolutions to process input features efficiently. It supports windowed attention for
    computational efficiency and includes residual connections.

    Attributes:
        dim (int): The dimensionality of the input and output.
        input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.
        num_heads (int): Number of attention heads.
        window_size (int): Size of the attention window.
        mlp_ratio (float): Ratio of MLP hidden dimension to embedding dimension.
        drop_path (nn.Module): Stochastic depth layer, identity function during inference.
        attn (Attention): Self-attention module.
        mlp (MLP): Multi-layer perceptron module.
        local_conv (Conv2d_BN): Depth-wise local convolution layer.

    Examples:
        >>> input_tensor = torch.randn(1, 196, 192)
        >>> block = TinyViTBlock(dim=192, input_resolution=(14, 14), num_heads=3)
        >>> output = block(input_tensor)
        >>> print(output.shape)
        torch.Size([1, 196, 192])
    """
    def __init__(self, dim: int, input_resolution: Tuple[int, int], num_heads: int, window_size: int = ..., mlp_ratio: float = ..., drop: float = ..., drop_path: float = ..., local_conv_size: int = ..., activation=...) -> None:
        """
        Initialize a TinyViT block with self-attention and local convolution.

        This block is a key component of the TinyViT architecture, combining self-attention mechanisms with
        local convolutions to process input features efficiently.

        Args:
            dim (int): Dimensionality of the input and output features.
            input_resolution (Tuple[int, int]): Spatial resolution of the input feature map (height, width).
            num_heads (int): Number of attention heads.
            window_size (int, optional): Size of the attention window. Must be greater than 0.
            mlp_ratio (float, optional): Ratio of MLP hidden dimension to embedding dimension.
            drop (float, optional): Dropout rate.
            drop_path (float, optional): Stochastic depth rate.
            local_conv_size (int, optional): Kernel size of the local convolution.
            activation (nn.Module): Activation function for MLP.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Apply self-attention, local convolution, and MLP operations to the input tensor."""
        ...
    
    def extra_repr(self) -> str:
        """
        Return a string representation of the TinyViTBlock's parameters.

        This method provides a formatted string containing key information about the TinyViTBlock, including its
        dimension, input resolution, number of attention heads, window size, and MLP ratio.

        Returns:
            (str): A formatted string containing the block's parameters.

        Examples:
            >>> block = TinyViTBlock(dim=192, input_resolution=(14, 14), num_heads=3, window_size=7, mlp_ratio=4.0)
            >>> print(block.extra_repr())
            dim=192, input_resolution=(14, 14), num_heads=3, window_size=7, mlp_ratio=4.0
        """
        ...
    


class BasicLayer(nn.Module):
    """
    A basic TinyViT layer for one stage in a TinyViT architecture.

    This class represents a single layer in the TinyViT model, consisting of multiple TinyViT blocks
    and an optional downsampling operation. It processes features at a specific resolution and
    dimensionality within the overall architecture.

    Attributes:
        dim (int): The dimensionality of the input and output features.
        input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.
        depth (int): Number of TinyViT blocks in this layer.
        use_checkpoint (bool): Whether to use gradient checkpointing to save memory.
        blocks (nn.ModuleList): List of TinyViT blocks that make up this layer.
        downsample (nn.Module | None): Downsample layer at the end of the layer, if specified.

    Examples:
        >>> input_tensor = torch.randn(1, 3136, 192)
        >>> layer = BasicLayer(dim=192, input_resolution=(56, 56), depth=2, num_heads=3, window_size=7)
        >>> output = layer(input_tensor)
        >>> print(output.shape)
        torch.Size([1, 784, 384])
    """
    def __init__(self, dim: int, input_resolution: Tuple[int, int], depth: int, num_heads: int, window_size: int, mlp_ratio: float = ..., drop: float = ..., drop_path: Union[float, List[float]] = ..., downsample: Optional[nn.Module] = ..., use_checkpoint: bool = ..., local_conv_size: int = ..., activation=..., out_dim: Optional[int] = ...) -> None:
        """
        Initialize a BasicLayer in the TinyViT architecture.

        This layer consists of multiple TinyViT blocks and an optional downsampling operation. It is designed to
        process feature maps at a specific resolution and dimensionality within the TinyViT model.

        Args:
            dim (int): Dimensionality of the input and output features.
            input_resolution (Tuple[int, int]): Spatial resolution of the input feature map (height, width).
            depth (int): Number of TinyViT blocks in this layer.
            num_heads (int): Number of attention heads in each TinyViT block.
            window_size (int): Size of the local window for attention computation.
            mlp_ratio (float, optional): Ratio of MLP hidden dimension to embedding dimension.
            drop (float, optional): Dropout rate.
            drop_path (float | List[float], optional): Stochastic depth rate. Can be a float or a list of floats for each block.
            downsample (nn.Module | None, optional): Downsampling layer at the end of the layer. None to skip downsampling.
            use_checkpoint (bool, optional): Whether to use gradient checkpointing to save memory.
            local_conv_size (int, optional): Kernel size for the local convolution in each TinyViT block.
            activation (nn.Module): Activation function used in the MLP.
            out_dim (int | None, optional): Output dimension after downsampling. None means it will be the same as `dim`.
        """
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Process input through TinyViT blocks and optional downsampling."""
        ...
    
    def extra_repr(self) -> str:
        """Return a string with the layer's parameters for printing."""
        ...
    


class TinyViT(nn.Module):
    """
    TinyViT: A compact vision transformer architecture for efficient image classification and feature extraction.

    This class implements the TinyViT model, which combines elements of vision transformers and convolutional
    neural networks for improved efficiency and performance on vision tasks. It features hierarchical processing
    with patch embedding, multiple stages of attention and convolution blocks, and a feature refinement neck.

    Attributes:
        img_size (int): Input image size.
        num_classes (int): Number of classification classes.
        depths (Tuple[int, int, int, int]): Number of blocks in each stage.
        num_layers (int): Total number of layers in the network.
        mlp_ratio (float): Ratio of MLP hidden dimension to embedding dimension.
        patch_embed (PatchEmbed): Module for patch embedding.
        patches_resolution (Tuple[int, int]): Resolution of embedded patches.
        layers (nn.ModuleList): List of network layers.
        norm_head (nn.LayerNorm): Layer normalization for the classifier head.
        head (nn.Linear): Linear layer for final classification.
        neck (nn.Sequential): Neck module for feature refinement.

    Examples:
        >>> model = TinyViT(img_size=224, num_classes=1000)
        >>> x = torch.randn(1, 3, 224, 224)
        >>> features = model.forward_features(x)
        >>> print(features.shape)
        torch.Size([1, 256, 56, 56])
    """
    def __init__(self, img_size: int = ..., in_chans: int = ..., num_classes: int = ..., embed_dims: Tuple[int, int, int, int] = ..., depths: Tuple[int, int, int, int] = ..., num_heads: Tuple[int, int, int, int] = ..., window_sizes: Tuple[int, int, int, int] = ..., mlp_ratio: float = ..., drop_rate: float = ..., drop_path_rate: float = ..., use_checkpoint: bool = ..., mbconv_expand_ratio: float = ..., local_conv_size: int = ..., layer_lr_decay: float = ...) -> None:
        """
        Initialize the TinyViT model.

        This constructor sets up the TinyViT architecture, including patch embedding, multiple layers of
        attention and convolution blocks, and a classification head.

        Args:
            img_size (int, optional): Size of the input image.
            in_chans (int, optional): Number of input channels.
            num_classes (int, optional): Number of classes for classification.
            embed_dims (Tuple[int, int, int, int], optional): Embedding dimensions for each stage.
            depths (Tuple[int, int, int, int], optional): Number of blocks in each stage.
            num_heads (Tuple[int, int, int, int], optional): Number of attention heads in each stage.
            window_sizes (Tuple[int, int, int, int], optional): Window sizes for each stage.
            mlp_ratio (float, optional): Ratio of MLP hidden dim to embedding dim.
            drop_rate (float, optional): Dropout rate.
            drop_path_rate (float, optional): Stochastic depth rate.
            use_checkpoint (bool, optional): Whether to use checkpointing to save memory.
            mbconv_expand_ratio (float, optional): Expansion ratio for MBConv layer.
            local_conv_size (int, optional): Kernel size for local convolutions.
            layer_lr_decay (float, optional): Layer-wise learning rate decay factor.
        """
        ...
    
    def set_layer_lr_decay(self, layer_lr_decay: float): # -> None:
        """Set layer-wise learning rate decay for the TinyViT model based on depth."""
        ...
    
    @torch.jit.ignore
    def no_weight_decay_keywords(self): # -> set[str]:
        """Return a set of keywords for parameters that should not use weight decay."""
        ...
    
    def forward_features(self, x: torch.Tensor) -> torch.Tensor:
        """Process input through feature extraction layers, returning spatial features."""
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Perform the forward pass through the TinyViT model, extracting features from the input image."""
        ...
    
    def set_imgsz(self, imgsz: List[int] = ...): # -> None:
        """Set image size to make model compatible with different image sizes."""
        ...
    


