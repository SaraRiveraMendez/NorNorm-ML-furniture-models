"""
This type stub file was generated by pyright.
"""

import numpy as np
import torch
from pathlib import Path
from typing import Any, Dict, List, Tuple, Union
from ultralytics.utils import DataExportMixin, SimpleClass, TryExcept, plt_settings

"""Model validation metrics."""
OKS_SIGMA = (np.array([0.26, 0.25, 0.25, 0.35, 0.35, 0.79, 0.79, 0.72, 0.72, 0.62, 0.62, 1.07, 1.07, 0.87, 0.87, 0.89, 0.89]) / 10)
def bbox_ioa(box1: np.ndarray, box2: np.ndarray, iou: bool = ..., eps: float = ...) -> np.ndarray:
    """
    Calculate the intersection over box2 area given box1 and box2.

    Args:
        box1 (np.ndarray): A numpy array of shape (N, 4) representing N bounding boxes in x1y1x2y2 format.
        box2 (np.ndarray): A numpy array of shape (M, 4) representing M bounding boxes in x1y1x2y2 format.
        iou (bool, optional): Calculate the standard IoU if True else return inter_area/box2_area.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (np.ndarray): A numpy array of shape (N, M) representing the intersection over box2 area.
    """
    ...

def box_iou(box1: torch.Tensor, box2: torch.Tensor, eps: float = ...) -> torch.Tensor:
    """
    Calculate intersection-over-union (IoU) of boxes.

    Args:
        box1 (torch.Tensor): A tensor of shape (N, 4) representing N bounding boxes in (x1, y1, x2, y2) format.
        box2 (torch.Tensor): A tensor of shape (M, 4) representing M bounding boxes in (x1, y1, x2, y2) format.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (torch.Tensor): An NxM tensor containing the pairwise IoU values for every element in box1 and box2.

    References:
        https://github.com/pytorch/vision/blob/main/torchvision/ops/boxes.py
    """
    ...

def bbox_iou(box1: torch.Tensor, box2: torch.Tensor, xywh: bool = ..., GIoU: bool = ..., DIoU: bool = ..., CIoU: bool = ..., eps: float = ...) -> torch.Tensor:
    """
    Calculate the Intersection over Union (IoU) between bounding boxes.

    This function supports various shapes for `box1` and `box2` as long as the last dimension is 4.
    For instance, you may pass tensors shaped like (4,), (N, 4), (B, N, 4), or (B, N, 1, 4).
    Internally, the code will split the last dimension into (x, y, w, h) if `xywh=True`,
    or (x1, y1, x2, y2) if `xywh=False`.

    Args:
        box1 (torch.Tensor): A tensor representing one or more bounding boxes, with the last dimension being 4.
        box2 (torch.Tensor): A tensor representing one or more bounding boxes, with the last dimension being 4.
        xywh (bool, optional): If True, input boxes are in (x, y, w, h) format. If False, input boxes are in
                               (x1, y1, x2, y2) format.
        GIoU (bool, optional): If True, calculate Generalized IoU.
        DIoU (bool, optional): If True, calculate Distance IoU.
        CIoU (bool, optional): If True, calculate Complete IoU.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (torch.Tensor): IoU, GIoU, DIoU, or CIoU values depending on the specified flags.
    """
    ...

def mask_iou(mask1: torch.Tensor, mask2: torch.Tensor, eps: float = ...) -> torch.Tensor:
    """
    Calculate masks IoU.

    Args:
        mask1 (torch.Tensor): A tensor of shape (N, n) where N is the number of ground truth objects and n is the
                        product of image width and height.
        mask2 (torch.Tensor): A tensor of shape (M, n) where M is the number of predicted objects and n is the
                        product of image width and height.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing masks IoU.
    """
    ...

def kpt_iou(kpt1: torch.Tensor, kpt2: torch.Tensor, area: torch.Tensor, sigma: List[float], eps: float = ...) -> torch.Tensor:
    """
    Calculate Object Keypoint Similarity (OKS).

    Args:
        kpt1 (torch.Tensor): A tensor of shape (N, 17, 3) representing ground truth keypoints.
        kpt2 (torch.Tensor): A tensor of shape (M, 17, 3) representing predicted keypoints.
        area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.
        sigma (list): A list containing 17 values representing keypoint scales.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing keypoint similarities.
    """
    ...

def probiou(obb1: torch.Tensor, obb2: torch.Tensor, CIoU: bool = ..., eps: float = ...) -> torch.Tensor:
    """
    Calculate probabilistic IoU between oriented bounding boxes.

    Args:
        obb1 (torch.Tensor): Ground truth OBBs, shape (N, 5), format xywhr.
        obb2 (torch.Tensor): Predicted OBBs, shape (N, 5), format xywhr.
        CIoU (bool, optional): If True, calculate CIoU.
        eps (float, optional): Small value to avoid division by zero.

    Returns:
        (torch.Tensor): OBB similarities, shape (N,).

    Notes:
        OBB format: [center_x, center_y, width, height, rotation_angle].

    References:
        https://arxiv.org/pdf/2106.06072v1.pdf
    """
    ...

def batch_probiou(obb1: Union[torch.Tensor, np.ndarray], obb2: Union[torch.Tensor, np.ndarray], eps: float = ...) -> torch.Tensor:
    """
    Calculate the probabilistic IoU between oriented bounding boxes.

    Args:
        obb1 (torch.Tensor | np.ndarray): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.
        obb2 (torch.Tensor | np.ndarray): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.
        eps (float, optional): A small value to avoid division by zero.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.

    References:
        https://arxiv.org/pdf/2106.06072v1.pdf
    """
    ...

def smooth_bce(eps: float = ...) -> Tuple[float, float]:
    """
    Compute smoothed positive and negative Binary Cross-Entropy targets.

    Args:
        eps (float, optional): The epsilon value for label smoothing.

    Returns:
        pos (float): Positive label smoothing BCE target.
        neg (float): Negative label smoothing BCE target.

    References:
        https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441
    """
    ...

class ConfusionMatrix(DataExportMixin):
    """
    A class for calculating and updating a confusion matrix for object detection and classification tasks.

    Attributes:
        task (str): The type of task, either 'detect' or 'classify'.
        matrix (np.ndarray): The confusion matrix, with dimensions depending on the task.
        nc (int): The number of category.
        names (List[str]): The names of the classes, used as labels on the plot.
        matches (dict): Contains the indices of ground truths and predictions categorized into TP, FP and FN.
    """
    def __init__(self, names: Dict[int, str] = ..., task: str = ..., save_matches: bool = ...) -> None:
        """
        Initialize a ConfusionMatrix instance.

        Args:
            names (Dict[int, str], optional): Names of classes, used as labels on the plot.
            task (str, optional): Type of task, either 'detect' or 'classify'.
            save_matches (bool, optional): Save the indices of GTs, TPs, FPs, FNs for visualization.
        """
        ...
    
    def process_cls_preds(self, preds: List[torch.Tensor], targets: List[torch.Tensor]) -> None:
        """
        Update confusion matrix for classification task.

        Args:
            preds (List[N, min(nc,5)]): Predicted class labels.
            targets (List[N, 1]): Ground truth class labels.
        """
        ...
    
    def process_batch(self, detections: Dict[str, torch.Tensor], batch: Dict[str, Any], conf: float = ..., iou_thres: float = ...) -> None:
        """
        Update confusion matrix for object detection task.

        Args:
            detections (Dict[str, torch.Tensor]): Dictionary containing detected bounding boxes and their associated information.
                                       Should contain 'cls', 'conf', and 'bboxes' keys, where 'bboxes' can be
                                       Array[N, 4] for regular boxes or Array[N, 5] for OBB with angle.
            batch (Dict[str, Any]): Batch dictionary containing ground truth data with 'bboxes' (Array[M, 4]| Array[M, 5]) and
                'cls' (Array[M]) keys, where M is the number of ground truth objects.
            conf (float, optional): Confidence threshold for detections.
            iou_thres (float, optional): IoU threshold for matching detections to ground truth.
        """
        ...
    
    def matrix(self): # -> Callable[[], ...]:
        """Return the confusion matrix."""
        ...
    
    def tp_fp(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        Return true positives and false positives.

        Returns:
            tp (np.ndarray): True positives.
            fp (np.ndarray): False positives.
        """
        ...
    
    def plot_matches(self, img: torch.Tensor, im_file: str, save_dir: Path) -> None:
        """
        Plot grid of GT, TP, FP, FN for each image.

        Args:
            img (torch.Tensor): Image to plot onto.
            im_file (str): Image filename to save visualizations.
            save_dir (Path): Location to save the visualizations to.
        """
        ...
    
    @TryExcept(msg="ConfusionMatrix plot failure")
    @plt_settings()
    def plot(self, normalize: bool = ..., save_dir: str = ..., on_plot=...): # -> None:
        """
        Plot the confusion matrix using matplotlib and save it to a file.

        Args:
            normalize (bool, optional): Whether to normalize the confusion matrix.
            save_dir (str, optional): Directory where the plot will be saved.
            on_plot (callable, optional): An optional callback to pass plots path and data when they are rendered.
        """
        ...
    
    def print(self): # -> None:
        """Print the confusion matrix to the console."""
        ...
    
    def summary(self, normalize: bool = ..., decimals: int = ...) -> List[Dict[str, float]]:
        """
        Generate a summarized representation of the confusion matrix as a list of dictionaries, with optional
        normalization. This is useful for exporting the matrix to various formats such as CSV, XML, HTML, JSON, or SQL.

        Args:
            normalize (bool): Whether to normalize the confusion matrix values.
            decimals (int): Number of decimal places to round the output values to.

        Returns:
            (List[Dict[str, float]]): A list of dictionaries, each representing one predicted class with corresponding values for all actual classes.

        Examples:
            >>> results = model.val(data="coco8.yaml", plots=True)
            >>> cm_dict = results.confusion_matrix.summary(normalize=True, decimals=5)
            >>> print(cm_dict)
        """
        ...
    


def smooth(y: np.ndarray, f: float = ...) -> np.ndarray:
    """Box filter of fraction f."""
    ...

@plt_settings()
def plot_pr_curve(px: np.ndarray, py: np.ndarray, ap: np.ndarray, save_dir: Path = ..., names: Dict[int, str] = ..., on_plot=...): # -> None:
    """
    Plot precision-recall curve.

    Args:
        px (np.ndarray): X values for the PR curve.
        py (np.ndarray): Y values for the PR curve.
        ap (np.ndarray): Average precision values.
        save_dir (Path, optional): Path to save the plot.
        names (Dict[int, str], optional): Dictionary mapping class indices to class names.
        on_plot (callable, optional): Function to call after plot is saved.
    """
    ...

@plt_settings()
def plot_mc_curve(px: np.ndarray, py: np.ndarray, save_dir: Path = ..., names: Dict[int, str] = ..., xlabel: str = ..., ylabel: str = ..., on_plot=...): # -> None:
    """
    Plot metric-confidence curve.

    Args:
        px (np.ndarray): X values for the metric-confidence curve.
        py (np.ndarray): Y values for the metric-confidence curve.
        save_dir (Path, optional): Path to save the plot.
        names (Dict[int, str], optional): Dictionary mapping class indices to class names.
        xlabel (str, optional): X-axis label.
        ylabel (str, optional): Y-axis label.
        on_plot (callable, optional): Function to call after plot is saved.
    """
    ...

def compute_ap(recall: List[float], precision: List[float]) -> Tuple[float, np.ndarray, np.ndarray]:
    """
    Compute the average precision (AP) given the recall and precision curves.

    Args:
        recall (list): The recall curve.
        precision (list): The precision curve.

    Returns:
        ap (float): Average precision.
        mpre (np.ndarray): Precision envelope curve.
        mrec (np.ndarray): Modified recall curve with sentinel values added at the beginning and end.
    """
    ...

def ap_per_class(tp: np.ndarray, conf: np.ndarray, pred_cls: np.ndarray, target_cls: np.ndarray, plot: bool = ..., on_plot=..., save_dir: Path = ..., names: Dict[int, str] = ..., eps: float = ..., prefix: str = ...) -> Tuple:
    """
    Compute the average precision per class for object detection evaluation.

    Args:
        tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).
        conf (np.ndarray): Array of confidence scores of the detections.
        pred_cls (np.ndarray): Array of predicted classes of the detections.
        target_cls (np.ndarray): Array of true classes of the detections.
        plot (bool, optional): Whether to plot PR curves or not.
        on_plot (callable, optional): A callback to pass plots path and data when they are rendered.
        save_dir (Path, optional): Directory to save the PR curves.
        names (Dict[int, str], optional): Dictionary of class names to plot PR curves.
        eps (float, optional): A small value to avoid division by zero.
        prefix (str, optional): A prefix string for saving the plot files.

    Returns:
        tp (np.ndarray): True positive counts at threshold given by max F1 metric for each class.
        fp (np.ndarray): False positive counts at threshold given by max F1 metric for each class.
        p (np.ndarray): Precision values at threshold given by max F1 metric for each class.
        r (np.ndarray): Recall values at threshold given by max F1 metric for each class.
        f1 (np.ndarray): F1-score values at threshold given by max F1 metric for each class.
        ap (np.ndarray): Average precision for each class at different IoU thresholds.
        unique_classes (np.ndarray): An array of unique classes that have data.
        p_curve (np.ndarray): Precision curves for each class.
        r_curve (np.ndarray): Recall curves for each class.
        f1_curve (np.ndarray): F1-score curves for each class.
        x (np.ndarray): X-axis values for the curves.
        prec_values (np.ndarray): Precision values at mAP@0.5 for each class.
    """
    ...

class Metric(SimpleClass):
    """
    Class for computing evaluation metrics for Ultralytics YOLO models.

    Attributes:
        p (list): Precision for each class. Shape: (nc,).
        r (list): Recall for each class. Shape: (nc,).
        f1 (list): F1 score for each class. Shape: (nc,).
        all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).
        ap_class_index (list): Index of class for each AP score. Shape: (nc,).
        nc (int): Number of classes.

    Methods:
        ap50: AP at IoU threshold of 0.5 for all classes.
        ap: AP at IoU thresholds from 0.5 to 0.95 for all classes.
        mp: Mean precision of all classes.
        mr: Mean recall of all classes.
        map50: Mean AP at IoU threshold of 0.5 for all classes.
        map75: Mean AP at IoU threshold of 0.75 for all classes.
        map: Mean AP at IoU thresholds from 0.5 to 0.95 for all classes.
        mean_results: Mean of results, returns mp, mr, map50, map.
        class_result: Class-aware result, returns p[i], r[i], ap50[i], ap[i].
        maps: mAP of each class.
        fitness: Model fitness as a weighted combination of metrics.
        update: Update metric attributes with new evaluation results.
        curves: Provides a list of curves for accessing specific metrics like precision, recall, F1, etc.
        curves_results: Provide a list of results for accessing specific metrics like precision, recall, F1, etc.
    """
    def __init__(self) -> None:
        """Initialize a Metric instance for computing evaluation metrics for the YOLOv8 model."""
        ...
    
    @property
    def ap50(self) -> Union[np.ndarray, List]:
        """
        Return the Average Precision (AP) at an IoU threshold of 0.5 for all classes.

        Returns:
            (np.ndarray | list): Array of shape (nc,) with AP50 values per class, or an empty list if not available.
        """
        ...
    
    @property
    def ap(self) -> Union[np.ndarray, List]:
        """
        Return the Average Precision (AP) at an IoU threshold of 0.5-0.95 for all classes.

        Returns:
            (np.ndarray | list): Array of shape (nc,) with AP50-95 values per class, or an empty list if not available.
        """
        ...
    
    @property
    def mp(self) -> float:
        """
        Return the Mean Precision of all classes.

        Returns:
            (float): The mean precision of all classes.
        """
        ...
    
    @property
    def mr(self) -> float:
        """
        Return the Mean Recall of all classes.

        Returns:
            (float): The mean recall of all classes.
        """
        ...
    
    @property
    def map50(self) -> float:
        """
        Return the mean Average Precision (mAP) at an IoU threshold of 0.5.

        Returns:
            (float): The mAP at an IoU threshold of 0.5.
        """
        ...
    
    @property
    def map75(self) -> float:
        """
        Return the mean Average Precision (mAP) at an IoU threshold of 0.75.

        Returns:
            (float): The mAP at an IoU threshold of 0.75.
        """
        ...
    
    @property
    def map(self) -> float:
        """
        Return the mean Average Precision (mAP) over IoU thresholds of 0.5 - 0.95 in steps of 0.05.

        Returns:
            (float): The mAP over IoU thresholds of 0.5 - 0.95 in steps of 0.05.
        """
        ...
    
    def mean_results(self) -> List[float]:
        """Return mean of results, mp, mr, map50, map."""
        ...
    
    def class_result(self, i: int) -> Tuple[float, float, float, float]:
        """Return class-aware result, p[i], r[i], ap50[i], ap[i]."""
        ...
    
    @property
    def maps(self) -> np.ndarray:
        """Return mAP of each class."""
        ...
    
    def fitness(self) -> float:
        """Return model fitness as a weighted combination of metrics."""
        ...
    
    def update(self, results: tuple): # -> None:
        """
        Update the evaluation metrics with a new set of results.

        Args:
            results (tuple): A tuple containing evaluation metrics:
                - p (list): Precision for each class.
                - r (list): Recall for each class.
                - f1 (list): F1 score for each class.
                - all_ap (list): AP scores for all classes and all IoU thresholds.
                - ap_class_index (list): Index of class for each AP score.
                - p_curve (list): Precision curve for each class.
                - r_curve (list): Recall curve for each class.
                - f1_curve (list): F1 curve for each class.
                - px (list): X values for the curves.
                - prec_values (list): Precision values for each class.
        """
        ...
    
    @property
    def curves(self) -> List:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self) -> List[List]:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    


class DetMetrics(SimpleClass, DataExportMixin):
    """
    Utility class for computing detection metrics such as precision, recall, and mean average precision (mAP).

    Attributes:
        names (Dict[int, str]): A dictionary of class names.
        box (Metric): An instance of the Metric class for storing detection results.
        speed (Dict[str, float]): A dictionary for storing execution times of different parts of the detection process.
        task (str): The task type, set to 'detect'.
        stats (Dict[str, List]): A dictionary containing lists for true positives, confidence scores, predicted classes, target classes, and target images.
        nt_per_class: Number of targets per class.
        nt_per_image: Number of targets per image.

    Methods:
        update_stats: Update statistics by appending new values to existing stat collections.
        process: Process predicted results for object detection and update metrics.
        clear_stats: Clear the stored statistics.
        keys: Return a list of keys for accessing specific metrics.
        mean_results: Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95.
        class_result: Return the result of evaluating the performance of an object detection model on a specific class.
        maps: Return mean Average Precision (mAP) scores per class.
        fitness: Return the fitness of box object.
        ap_class_index: Return the average precision index per class.
        results_dict: Return dictionary of computed performance metrics and statistics.
        curves: Return a list of curves for accessing specific metrics curves.
        curves_results: Return a list of computed performance metrics and statistics.
        summary: Generate a summarized representation of per-class detection metrics as a list of dictionaries.
    """
    def __init__(self, names: Dict[int, str] = ...) -> None:
        """
        Initialize a DetMetrics instance with a save directory, plot flag, and class names.

        Args:
            names (Dict[int, str], optional): Dictionary of class names.
        """
        ...
    
    def update_stats(self, stat: Dict[str, Any]) -> None:
        """
        Update statistics by appending new values to existing stat collections.

        Args:
            stat (Dict[str, any]): Dictionary containing new statistical values to append.
                         Keys should match existing keys in self.stats.
        """
        ...
    
    def process(self, save_dir: Path = ..., plot: bool = ..., on_plot=...) -> Dict[str, np.ndarray]:
        """
        Process predicted results for object detection and update metrics.

        Args:
            save_dir (Path): Directory to save plots. Defaults to Path(".").
            plot (bool): Whether to plot precision-recall curves. Defaults to False.
            on_plot (callable, optional): Function to call after plots are generated. Defaults to None.

        Returns:
            (Dict[str, np.ndarray]): Dictionary containing concatenated statistics arrays.
        """
        ...
    
    def clear_stats(self): # -> None:
        """Clear the stored statistics."""
        ...
    
    @property
    def keys(self) -> List[str]:
        """Return a list of keys for accessing specific metrics."""
        ...
    
    def mean_results(self) -> List[float]:
        """Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95."""
        ...
    
    def class_result(self, i: int) -> Tuple[float, float, float, float]:
        """Return the result of evaluating the performance of an object detection model on a specific class."""
        ...
    
    @property
    def maps(self) -> np.ndarray:
        """Return mean Average Precision (mAP) scores per class."""
        ...
    
    @property
    def fitness(self) -> float:
        """Return the fitness of box object."""
        ...
    
    @property
    def ap_class_index(self) -> List:
        """Return the average precision index per class."""
        ...
    
    @property
    def results_dict(self) -> Dict[str, float]:
        """Return dictionary of computed performance metrics and statistics."""
        ...
    
    @property
    def curves(self) -> List[str]:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self) -> List[List]:
        """Return a list of computed performance metrics and statistics."""
        ...
    
    def summary(self, normalize: bool = ..., decimals: int = ...) -> List[Dict[str, Any]]:
        """
        Generate a summarized representation of per-class detection metrics as a list of dictionaries. Includes shared
        scalar metrics (mAP, mAP50, mAP75) alongside precision, recall, and F1-score for each class.

        Args:
           normalize (bool): For Detect metrics, everything is normalized  by default [0-1].
           decimals (int): Number of decimal places to round the metrics values to.

        Returns:
           (List[Dict[str, Any]]): A list of dictionaries, each representing one class with corresponding metric values.

        Examples:
           >>> results = model.val(data="coco8.yaml")
           >>> detection_summary = results.summary()
           >>> print(detection_summary)
        """
        ...
    


class SegmentMetrics(DetMetrics):
    """
    Calculate and aggregate detection and segmentation metrics over a given set of classes.

    Attributes:
        names (Dict[int, str]): Dictionary of class names.
        box (Metric): An instance of the Metric class for storing detection results.
        seg (Metric): An instance of the Metric class to calculate mask segmentation metrics.
        speed (Dict[str, float]): A dictionary for storing execution times of different parts of the detection process.
        task (str): The task type, set to 'segment'.
        stats (Dict[str, List]): A dictionary containing lists for true positives, confidence scores, predicted classes, target classes, and target images.
        nt_per_class: Number of targets per class.
        nt_per_image: Number of targets per image.

    Methods:
        process: Process the detection and segmentation metrics over the given set of predictions.
        keys: Return a list of keys for accessing metrics.
        mean_results: Return the mean metrics for bounding box and segmentation results.
        class_result: Return classification results for a specified class index.
        maps: Return mAP scores for object detection and semantic segmentation models.
        fitness: Return the fitness score for both segmentation and bounding box models.
        curves: Return a list of curves for accessing specific metrics curves.
        curves_results: Provide a list of computed performance metrics and statistics.
        summary: Generate a summarized representation of per-class segmentation metrics as a list of dictionaries.
    """
    def __init__(self, names: Dict[int, str] = ...) -> None:
        """
        Initialize a SegmentMetrics instance with a save directory, plot flag, and class names.

        Args:
            names (Dict[int, str], optional): Dictionary of class names.
        """
        ...
    
    def process(self, save_dir: Path = ..., plot: bool = ..., on_plot=...) -> Dict[str, np.ndarray]:
        """
        Process the detection and segmentation metrics over the given set of predictions.

        Args:
            save_dir (Path): Directory to save plots. Defaults to Path(".").
            plot (bool): Whether to plot precision-recall curves. Defaults to False.
            on_plot (callable, optional): Function to call after plots are generated. Defaults to None.

        Returns:
            (Dict[str, np.ndarray]): Dictionary containing concatenated statistics arrays.
        """
        ...
    
    @property
    def keys(self) -> List[str]:
        """Return a list of keys for accessing metrics."""
        ...
    
    def mean_results(self) -> List[float]:
        """Return the mean metrics for bounding box and segmentation results."""
        ...
    
    def class_result(self, i: int) -> List[float]:
        """Return classification results for a specified class index."""
        ...
    
    @property
    def maps(self) -> np.ndarray:
        """Return mAP scores for object detection and semantic segmentation models."""
        ...
    
    @property
    def fitness(self) -> float:
        """Return the fitness score for both segmentation and bounding box models."""
        ...
    
    @property
    def curves(self) -> List[str]:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self) -> List[List]:
        """Return a list of computed performance metrics and statistics."""
        ...
    
    def summary(self, normalize: bool = ..., decimals: int = ...) -> List[Dict[str, Any]]:
        """
        Generate a summarized representation of per-class segmentation metrics as a list of dictionaries. Includes both
        box and mask scalar metrics (mAP, mAP50, mAP75) alongside precision, recall, and F1-score for each class.

        Args:
            normalize (bool): For Segment metrics, everything is normalized  by default [0-1].
            decimals (int): Number of decimal places to round the metrics values to.

        Returns:
            (List[Dict[str, Any]]): A list of dictionaries, each representing one class with corresponding metric values.

        Examples:
            >>> results = model.val(data="coco8-seg.yaml")
            >>> seg_summary = results.summary(decimals=4)
            >>> print(seg_summary)
        """
        ...
    


class PoseMetrics(DetMetrics):
    """
    Calculate and aggregate detection and pose metrics over a given set of classes.

    Attributes:
        names (Dict[int, str]): Dictionary of class names.
        pose (Metric): An instance of the Metric class to calculate pose metrics.
        box (Metric): An instance of the Metric class for storing detection results.
        speed (Dict[str, float]): A dictionary for storing execution times of different parts of the detection process.
        task (str): The task type, set to 'pose'.
        stats (Dict[str, List]): A dictionary containing lists for true positives, confidence scores, predicted classes, target classes, and target images.
        nt_per_class: Number of targets per class.
        nt_per_image: Number of targets per image.

    Methods:
        process: Process the detection and pose metrics over the given set of predictions. R
        keys: Return a list of keys for accessing metrics.
        mean_results: Return the mean results of box and pose.
        class_result: Return the class-wise detection results for a specific class i.
        maps: Return the mean average precision (mAP) per class for both box and pose detections.
        fitness: Return combined fitness score for pose and box detection.
        curves: Return a list of curves for accessing specific metrics curves.
        curves_results: Provide a list of computed performance metrics and statistics.
        summary: Generate a summarized representation of per-class pose metrics as a list of dictionaries.
    """
    def __init__(self, names: Dict[int, str] = ...) -> None:
        """
        Initialize the PoseMetrics class with directory path, class names, and plotting options.

        Args:
            names (Dict[int, str], optional): Dictionary of class names.
        """
        ...
    
    def process(self, save_dir: Path = ..., plot: bool = ..., on_plot=...) -> Dict[str, np.ndarray]:
        """
        Process the detection and pose metrics over the given set of predictions.

        Args:
            save_dir (Path): Directory to save plots. Defaults to Path(".").
            plot (bool): Whether to plot precision-recall curves. Defaults to False.
            on_plot (callable, optional): Function to call after plots are generated.

        Returns:
            (Dict[str, np.ndarray]): Dictionary containing concatenated statistics arrays.
        """
        ...
    
    @property
    def keys(self) -> List[str]:
        """Return a list of evaluation metric keys."""
        ...
    
    def mean_results(self) -> List[float]:
        """Return the mean results of box and pose."""
        ...
    
    def class_result(self, i: int) -> List[float]:
        """Return the class-wise detection results for a specific class i."""
        ...
    
    @property
    def maps(self) -> np.ndarray:
        """Return the mean average precision (mAP) per class for both box and pose detections."""
        ...
    
    @property
    def fitness(self) -> float:
        """Return combined fitness score for pose and box detection."""
        ...
    
    @property
    def curves(self) -> List[str]:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self) -> List[List]:
        """Return a list of computed performance metrics and statistics."""
        ...
    
    def summary(self, normalize: bool = ..., decimals: int = ...) -> List[Dict[str, Any]]:
        """
        Generate a summarized representation of per-class pose metrics as a list of dictionaries. Includes both box and
        pose scalar metrics (mAP, mAP50, mAP75) alongside precision, recall, and F1-score for each class.

        Args:
            normalize (bool): For Pose metrics, everything is normalized  by default [0-1].
            decimals (int): Number of decimal places to round the metrics values to.

        Returns:
            (List[Dict[str, Any]]): A list of dictionaries, each representing one class with corresponding metric values.

        Examples:
            >>> results = model.val(data="coco8-pose.yaml")
            >>> pose_summary = results.summary(decimals=4)
            >>> print(pose_summary)
        """
        ...
    


class ClassifyMetrics(SimpleClass, DataExportMixin):
    """
    Class for computing classification metrics including top-1 and top-5 accuracy.

    Attributes:
        top1 (float): The top-1 accuracy.
        top5 (float): The top-5 accuracy.
        speed (dict): A dictionary containing the time taken for each step in the pipeline.
        task (str): The task type, set to 'classify'.

    Methods:
        process: Process target classes and predicted classes to compute metrics.
        fitness: Return mean of top-1 and top-5 accuracies as fitness score.
        results_dict: Return a dictionary with model's performance metrics and fitness score.
        keys: Return a list of keys for the results_dict property.
        curves: Return a list of curves for accessing specific metrics curves.
        curves_results: Provide a list of computed performance metrics and statistics.
        summary: Generate a single-row summary of classification metrics (Top-1 and Top-5 accuracy).
    """
    def __init__(self) -> None:
        """Initialize a ClassifyMetrics instance."""
        ...
    
    def process(self, targets: torch.Tensor, pred: torch.Tensor): # -> None:
        """
        Process target classes and predicted classes to compute metrics.

        Args:
            targets (torch.Tensor): Target classes.
            pred (torch.Tensor): Predicted classes.
        """
        ...
    
    @property
    def fitness(self) -> float:
        """Return mean of top-1 and top-5 accuracies as fitness score."""
        ...
    
    @property
    def results_dict(self) -> Dict[str, float]:
        """Return a dictionary with model's performance metrics and fitness score."""
        ...
    
    @property
    def keys(self) -> List[str]:
        """Return a list of keys for the results_dict property."""
        ...
    
    @property
    def curves(self) -> List:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self) -> List:
        """Return a list of curves for accessing specific metrics curves."""
        ...
    
    def summary(self, normalize: bool = ..., decimals: int = ...) -> List[Dict[str, float]]:
        """
        Generate a single-row summary of classification metrics (Top-1 and Top-5 accuracy).

        Args:
            normalize (bool): For Classify metrics, everything is normalized  by default [0-1].
            decimals (int): Number of decimal places to round the metrics values to.

        Returns:
            (List[Dict[str, float]]): A list with one dictionary containing Top-1 and Top-5 classification accuracy.

        Examples:
            >>> results = model.val(data="imagenet10")
            >>> classify_summary = results.summary(decimals=4)
            >>> print(classify_summary)
        """
        ...
    


class OBBMetrics(DetMetrics):
    """
    Metrics for evaluating oriented bounding box (OBB) detection.

    Attributes:
        names (Dict[int, str]): Dictionary of class names.
        box (Metric): An instance of the Metric class for storing detection results.
        speed (Dict[str, float]): A dictionary for storing execution times of different parts of the detection process.
        task (str): The task type, set to 'obb'.
        stats (Dict[str, List]): A dictionary containing lists for true positives, confidence scores, predicted classes, target classes, and target images.
        nt_per_class: Number of targets per class.
        nt_per_image: Number of targets per image.

    References:
        https://arxiv.org/pdf/2106.06072.pdf
    """
    def __init__(self, names: Dict[int, str] = ...) -> None:
        """
        Initialize an OBBMetrics instance with directory, plotting, and class names.

        Args:
            names (Dict[int, str], optional): Dictionary of class names.
        """
        ...
    


